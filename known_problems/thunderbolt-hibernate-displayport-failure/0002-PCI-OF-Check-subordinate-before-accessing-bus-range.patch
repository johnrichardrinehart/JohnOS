diff --git a/drivers/pci/of_property.c b/drivers/pci/of_property.c
index 7aae46f333d9d..3dee3af1f9b03 100644
--- a/drivers/pci/of_property.c
+++ b/drivers/pci/of_property.c
@@ -95,8 +95,18 @@ static int of_pci_prop_bus_range(struct pci_dev *pdev,
 				 struct of_changeset *ocs,
 				 struct device_node *np)
 {
-	u32 bus_range[] = { pdev->subordinate->busn_res.start,
-			    pdev->subordinate->busn_res.end };
+	u32 bus_range[2];
+
+	/*
+	 * The subordinate bus may be NULL if the bridge is in an error
+	 * state (e.g., failed power state transition, device inaccessible).
+	 * This can happen during hotplug if the device hasn't fully recovered.
+	 */
+	if (!pdev->subordinate)
+		return -ENODEV;
+
+	bus_range[0] = pdev->subordinate->busn_res.start;
+	bus_range[1] = pdev->subordinate->busn_res.end;
 
 	return of_changeset_add_prop_u32_array(ocs, np, "bus-range", bus_range,
 					       ARRAY_SIZE(bus_range));
@@ -220,6 +230,10 @@ static int of_pci_prop_intr_map(struct pci_dev *pdev, struct of_changeset *ocs,
 	int ret;
 	u8 pin;
 
+	/* Subordinate bus required for interrupt map traversal */
+	if (!pdev->subordinate)
+		return -ENODEV;
+
 	pnode = pci_device_to_OF_node(pdev->bus->self);
 	if (!pnode)
 		pnode = pci_bus_to_OF_node(pdev->bus);
