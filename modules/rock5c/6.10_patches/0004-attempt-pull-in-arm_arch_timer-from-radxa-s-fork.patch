From 2bbae21a6ef35436820ac29126e6a0223847cda6 Mon Sep 17 00:00:00 2001
From: John Rinehart <johnrichardrinehart@gmail.com>
Date: Thu, 21 Nov 2024 13:07:48 -0800
Subject: [PATCH 4/4] attempt: pull in arm_arch_timer from radxa's fork

---
 drivers/clocksource/arm_arch_timer.c | 107 ++++++++-------------------
 include/linux/timer.h                |   1 -
 2 files changed, 30 insertions(+), 78 deletions(-)

diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index aeafc74181f0..20739d28a3fd 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -191,40 +191,22 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 	return val;
 }
 
-static noinstr u64 raw_counter_get_cntpct_stable(void)
-{
-	return __arch_counter_get_cntpct_stable();
-}
-
 static notrace u64 arch_counter_get_cntpct_stable(void)
 {
-	u64 val;
-	preempt_disable_notrace();
-	val = __arch_counter_get_cntpct_stable();
-	preempt_enable_notrace();
-	return val;
+	return __arch_counter_get_cntpct_stable();
 }
 
-static noinstr u64 arch_counter_get_cntpct(void)
+static notrace u64 arch_counter_get_cntpct(void)
 {
 	return __arch_counter_get_cntpct();
 }
 
-static noinstr u64 raw_counter_get_cntvct_stable(void)
-{
-	return __arch_counter_get_cntvct_stable();
-}
-
 static notrace u64 arch_counter_get_cntvct_stable(void)
 {
-	u64 val;
-	preempt_disable_notrace();
-	val = __arch_counter_get_cntvct_stable();
-	preempt_enable_notrace();
-	return val;
+	return __arch_counter_get_cntvct_stable();
 }
 
-static noinstr u64 arch_counter_get_cntvct(void)
+static notrace u64 arch_counter_get_cntvct(void)
 {
 	return __arch_counter_get_cntvct();
 }
@@ -331,7 +313,7 @@ static u64 notrace hisi_161010101_read_cntvct_el0(void)
 	return __hisi_161010101_read_reg(cntvct_el0);
 }
 
-static const struct ate_acpi_oem_info hisi_161010101_oem_info[] = {
+static struct ate_acpi_oem_info hisi_161010101_oem_info[] = {
 	/*
 	 * Note that trailing spaces are required to properly match
 	 * the OEM table information.
@@ -706,8 +688,8 @@ static irqreturn_t arch_timer_handler_virt_mem(int irq, void *dev_id)
 	return timer_handler(ARCH_TIMER_MEM_VIRT_ACCESS, evt);
 }
 
-static __always_inline int arch_timer_shutdown(const int access,
-					       struct clock_event_device *clk)
+static __always_inline int timer_shutdown(const int access,
+					  struct clock_event_device *clk)
 {
 	unsigned long ctrl;
 
@@ -720,22 +702,22 @@ static __always_inline int arch_timer_shutdown(const int access,
 
 static int arch_timer_shutdown_virt(struct clock_event_device *clk)
 {
-	return arch_timer_shutdown(ARCH_TIMER_VIRT_ACCESS, clk);
+	return timer_shutdown(ARCH_TIMER_VIRT_ACCESS, clk);
 }
 
 static int arch_timer_shutdown_phys(struct clock_event_device *clk)
 {
-	return arch_timer_shutdown(ARCH_TIMER_PHYS_ACCESS, clk);
+	return timer_shutdown(ARCH_TIMER_PHYS_ACCESS, clk);
 }
 
 static int arch_timer_shutdown_virt_mem(struct clock_event_device *clk)
 {
-	return arch_timer_shutdown(ARCH_TIMER_MEM_VIRT_ACCESS, clk);
+	return timer_shutdown(ARCH_TIMER_MEM_VIRT_ACCESS, clk);
 }
 
 static int arch_timer_shutdown_phys_mem(struct clock_event_device *clk)
 {
-	return arch_timer_shutdown(ARCH_TIMER_MEM_PHYS_ACCESS, clk);
+	return timer_shutdown(ARCH_TIMER_MEM_PHYS_ACCESS, clk);
 }
 
 static __always_inline void set_next_event(const int access, unsigned long evt,
@@ -771,14 +753,14 @@ static int arch_timer_set_next_event_phys(unsigned long evt,
 	return 0;
 }
 
-static noinstr u64 arch_counter_get_cnt_mem(struct arch_timer *t, int offset_lo)
+static u64 arch_counter_get_cnt_mem(struct arch_timer *t, int offset_lo)
 {
 	u32 cnt_lo, cnt_hi, tmp_hi;
 
 	do {
-		cnt_hi = __le32_to_cpu((__le32 __force)__raw_readl(t->base + offset_lo + 4));
-		cnt_lo = __le32_to_cpu((__le32 __force)__raw_readl(t->base + offset_lo));
-		tmp_hi = __le32_to_cpu((__le32 __force)__raw_readl(t->base + offset_lo + 4));
+		cnt_hi = readl_relaxed(t->base + offset_lo + 4);
+		cnt_lo = readl_relaxed(t->base + offset_lo);
+		tmp_hi = readl_relaxed(t->base + offset_lo + 4);
 	} while (cnt_hi != tmp_hi);
 
 	return ((u64) cnt_hi << 32) | cnt_lo;
@@ -918,7 +900,7 @@ static void arch_timer_evtstrm_enable(unsigned int divider)
 
 #ifdef CONFIG_ARM64
 	/* ECV is likely to require a large divider. Use the EVNTIS flag. */
-	if (cpus_have_final_cap(ARM64_HAS_ECV) && divider > 15) {
+	if (cpus_have_const_cap(ARM64_HAS_ECV) && divider > 15) {
 		cntkctl |= ARCH_TIMER_EVT_INTERVAL_SCALE;
 		divider -= 8;
 	}
@@ -956,30 +938,6 @@ static void arch_timer_configure_evtstream(void)
 	arch_timer_evtstrm_enable(max(0, lsb));
 }
 
-static int arch_timer_evtstrm_starting_cpu(unsigned int cpu)
-{
-	arch_timer_configure_evtstream();
-	return 0;
-}
-
-static int arch_timer_evtstrm_dying_cpu(unsigned int cpu)
-{
-	cpumask_clear_cpu(smp_processor_id(), &evtstrm_available);
-	return 0;
-}
-
-static int __init arch_timer_evtstrm_register(void)
-{
-	if (!arch_timer_evt || !evtstrm_enable)
-		return 0;
-
-	return cpuhp_setup_state(CPUHP_AP_ARM_ARCH_TIMER_EVTSTRM_STARTING,
-				 "clockevents/arm/arch_timer_evtstrm:starting",
-				 arch_timer_evtstrm_starting_cpu,
-				 arch_timer_evtstrm_dying_cpu);
-}
-core_initcall(arch_timer_evtstrm_register);
-
 static void arch_counter_set_user_access(void)
 {
 	u32 cntkctl = arch_timer_get_cntkctl();
@@ -1041,6 +999,8 @@ static int arch_timer_starting_cpu(unsigned int cpu)
 	}
 
 	arch_counter_set_user_access();
+	if (evtstrm_enable)
+		arch_timer_configure_evtstream();
 
 	return 0;
 }
@@ -1108,7 +1068,7 @@ bool arch_timer_evtstrm_available(void)
 	return cpumask_test_cpu(raw_smp_processor_id(), &evtstrm_available);
 }
 
-static noinstr u64 arch_counter_get_cntvct_mem(void)
+static u64 arch_counter_get_cntvct_mem(void)
 {
 	return arch_counter_get_cnt_mem(arch_timer_mem, CNTVCT_LO);
 }
@@ -1122,7 +1082,6 @@ struct arch_timer_kvm_info *arch_timer_get_kvm_info(void)
 
 static void __init arch_counter_register(unsigned type)
 {
-	u64 (*scr)(void);
 	u64 start_count;
 	int width;
 
@@ -1132,28 +1091,21 @@ static void __init arch_counter_register(unsigned type)
 
 		if ((IS_ENABLED(CONFIG_ARM64) && !is_hyp_mode_available()) ||
 		    arch_timer_uses_ppi == ARCH_TIMER_VIRT_PPI) {
-			if (arch_timer_counter_has_wa()) {
+			if (arch_timer_counter_has_wa())
 				rd = arch_counter_get_cntvct_stable;
-				scr = raw_counter_get_cntvct_stable;
-			} else {
+			else
 				rd = arch_counter_get_cntvct;
-				scr = arch_counter_get_cntvct;
-			}
 		} else {
-			if (arch_timer_counter_has_wa()) {
+			if (arch_timer_counter_has_wa())
 				rd = arch_counter_get_cntpct_stable;
-				scr = raw_counter_get_cntpct_stable;
-			} else {
+			else
 				rd = arch_counter_get_cntpct;
-				scr = arch_counter_get_cntpct;
-			}
 		}
 
 		arch_timer_read_counter = rd;
 		clocksource_counter.vdso_clock_mode = vdso_default;
 	} else {
 		arch_timer_read_counter = arch_counter_get_cntvct_mem;
-		scr = arch_counter_get_cntvct_mem;
 	}
 
 	width = arch_counter_get_width();
@@ -1169,7 +1121,7 @@ static void __init arch_counter_register(unsigned type)
 	timecounter_init(&arch_timer_kvm_info.timecounter,
 			 &cyclecounter, start_count);
 
-	sched_clock_register(scr, width, arch_timer_rate);
+	sched_clock_register(arch_timer_read_counter, width, arch_timer_rate);
 }
 
 static void arch_timer_stop(struct clock_event_device *clk)
@@ -1187,6 +1139,8 @@ static int arch_timer_dying_cpu(unsigned int cpu)
 {
 	struct clock_event_device *clk = this_cpu_ptr(arch_timer_evt);
 
+	cpumask_clear_cpu(smp_processor_id(), &evtstrm_available);
+
 	arch_timer_stop(clk);
 	return 0;
 }
@@ -1300,7 +1254,6 @@ static int __init arch_timer_register(void)
 
 out_free:
 	free_percpu(arch_timer_evt);
-	arch_timer_evt = NULL;
 out:
 	return err;
 }
@@ -1556,7 +1509,7 @@ static int __init
 arch_timer_mem_frame_register(struct arch_timer_mem_frame *frame)
 {
 	void __iomem *base;
-	int ret, irq;
+	int ret, irq = 0;
 
 	if (arch_timer_mem_use_virtual)
 		irq = frame->virt_irq;
@@ -1807,7 +1760,7 @@ TIMER_ACPI_DECLARE(arch_timer, ACPI_SIG_GTDT, arch_timer_acpi_init);
 #endif
 
 int kvm_arch_ptp_get_crosststamp(u64 *cycle, struct timespec64 *ts,
-				 enum clocksource_ids *cs_id)
+				 struct clocksource **cs)
 {
 	struct arm_smccc_res hvc_res;
 	u32 ptp_counter;
@@ -1831,8 +1784,8 @@ int kvm_arch_ptp_get_crosststamp(u64 *cycle, struct timespec64 *ts,
 	*ts = ktime_to_timespec64(ktime);
 	if (cycle)
 		*cycle = (u64)hvc_res.a2 << 32 | hvc_res.a3;
-	if (cs_id)
-		*cs_id = CSID_ARM_ARCH_COUNTER;
+	if (cs)
+		*cs = &clocksource_counter;
 
 	return 0;
 }
diff --git a/include/linux/timer.h b/include/linux/timer.h
index e67ecd1cbc97..f2c11176f22e 100644
--- a/include/linux/timer.h
+++ b/include/linux/timer.h
@@ -166,7 +166,6 @@ extern int try_to_del_timer_sync(struct timer_list *timer);
 extern int timer_delete_sync(struct timer_list *timer);
 extern int timer_delete(struct timer_list *timer);
 extern int timer_shutdown_sync(struct timer_list *timer);
-extern int timer_shutdown(struct timer_list *timer);
 
 /**
  * del_timer_sync - Delete a pending timer and wait for a running callback
-- 
2.42.0

